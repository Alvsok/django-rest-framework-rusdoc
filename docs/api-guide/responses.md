source: response.py

# Responses

> В отличие от базовых HttpResponse объектов, TemplateResponse объекты сохраняют детали контекста который был предоставлен view чтобы вычислить ответ. Конечные выводы ответа не вычиляются до необходимости, позднее в процессе ответа.
>
> &mdash; [Django documentation][cite]

REST framework поддерживает HTTP согласование содержимого посредством класса `Response` который позволяет вам вернуть контент который может быть преобразовано во множество типов, в зависимости от запроса клиента.

Класс `Response` является подклассом Джанго класса `SimpleTemplateResponse`. Объекты `Response` инициализируются данными, которые должны состоять из примитивных типов данных Python. REST Framework затем использует стандартное HTTP согласование содержимого чтобы определить как будет преобразован конечный ответ.

Не обязательно использовать только класс `Response`, вы также можете вернуть обычный `HttpResponse` или `StreamingHttpResponse` объекты из вашего view если это понадобится. Использования класса `Response` просто дает лучший интерфейс для возврата содержательного Web API ответа, что затем может быть конвертированно во множество форматов.

До тех пор пока вы не захотите сильно изменить REST framework по каким-то причинам, вам следует всегда использовать класс `APIView` или `@api_view` для view которые возвращают `Response` объекты. Действуя так, убедитесь что view может производить согласование содержимого и выбирать соответсвующее положение для ответа, до того как его вернет view.

---

# Создание ответов

## Response()

**Signature:** `Response(data, status=None, template_name=None, headers=None, content_type=None)`

В отличие от обычных объектов `HttpResponse`, вам не надо создавать объекты `Response` с преобразованным контентом. Вместо этого, вы отправляете необработанные данные, которые могут содержать любой примитив Python.

Обработчики используемые классом `Response` не могут обрабатывать сложные типы данных, такие как экземпляры Джанго модели, так что вам необходимо сначала сериализовать данные в примитивы, прежде чем создавать объект `Response`.

Вы можете использовать класс `Serializer` для этой работы, или использовать любой ваш собственный класс.

Аргументы:

* `data`: Сериализованные данные для ответа.
* `status`: Статус код ответа. По умолчанию - 200. Смотрите также [статус коды][statuscodes].
* `template_name`: Имя шаблона для использования если `HTMLRenderer` выбран.
* `headers`: Словарь HTTP хедерова для использования в ответе.
* `content_type`: Тип контента ответа. Обычно, он будет установлен автоматически обработчиком как определен согласованием содержимого, но бывают случаи когда есть необходимость определить тип контента явно.

---

# Атрибуты

## .data

Необрабатываемый контент объекта `Request`

## .status_code

Цифровой статус кода HTTP ответа.

## .content

Обработанный контент ответа. Метод `.render()` должен быть вызван до доступности `.content`.

## .template_name

`template_name` - если есть. Требуется только если `HTMLRenderer` или какой-либой другой обработчки шаблонов применяемый для ответа.

## .accepted_renderer

Экземпляр обработчика который будет использоватся для ответа.

Устанавливается автоматически `APIView` или `@api_view` сразу до ответа возращенного из view.

## .accepted_media_type

Тип медиа который был выбран на этапе взаимодействия контента.

Устанавливается автоматически `APIView` или `@api_view` сразу до ответа возращенного из view.

## .renderer_context

Словарь дополнительной контекстной информации которая будет использована для метода `.render()`

Устанавливается автоматически `APIView` или `@api_view` сразу до ответа возращенного из view.

---

# Стандартные атрибуты HttpResponse

Класс `Response` расширяет `SimplrTemplateResponse` и все обычные атрибуты и методы которые доступны для ответа. Для примера вы можете установить хедеры для ответа стандартным способом:

    response = Response()
    response['Cache-Control'] = 'no-cache'

## .render()

**Signature:** `.render()`

Как с любым другим `TemplateResponse`, этот метод вызывается для обработки сериализованных данных ответа в конечном контент ответе. Когда `.render()` вызывается, контент ответа будет устанавливать результат вызова `.render(data, accepted_media_type, renderer_context)` экземпляра `accepted_renderer`.

Вам обычно не понадобится вызывать `.render()` самому, как это сделано в Джанго.

[cite]: https://docs.djangoproject.com/en/dev/ref/template-response/
[statuscodes]: status-codes.md
